<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta http-equiv="Content-Script-Type" content="text/javascript">
  <meta name="keywords" content="Aoki,Atsushi,Smalltalk,Smalltalker,Program,Programmer,Object,Oriented,Programming">
  <meta name="description" content="ソフトウェア工学IIのホームページ">
  <meta name="author" content="AOKI Atsushi">
  <link rev="made" href="index.html">
  <link rel="index" href="index.html">
  <style type="text/css">
    <!--
    body {
      background-color: #ffffff;
      margin: 20px;
      padding: 10px;
      font-family: serif;
      font-size: 10pt;
    }

    a {
      text-decoration: underline;
      color: #000000;
    }

    a:link {
      background-color: #ffddbb;
    }

    a:visited {
      background-color: #ccffcc;
    }

    a:hover {
      background-color: #dddddd;
    }

    a:active {
      background-color: #dddddd;
    }

    div.belt {
      background-color: #eeeeee;
      padding: 0px 4px;
    }

    div.belt-yellow {
      background-color: #ffffcc;
      padding: 0px 4px;
    }

    div.belt-blue {
      background-color: #ddeeff;
      padding: 0px 4px;
    }

    div.right-small {
      text-align: right;
      font-size: 8pt;
    }

    img.border {
      border-width: 1px;
      border-color: #000000;
      vertical-align: middle;
    }

    img.borderless {
      border-width: 0px;
      vertical-align: middle;
    }

    p.belt {
      background-color: #ffeedd;
      padding: 4px 8px;
    }

    p.belt-blue {
      background-color: #ddeeff;
      padding: 4px 8px;
    }

    pre.belt {
      background-color: #ddeeff;
      padding: 4px 8px;
    }

    pre.belt-yellow {
      background-color: #ffffcc;
      padding: 4px 8px;
    }

    table {
      border-style: solid;
      border-width: 0px;
      border-color: #000000;
      font-family: serif;
      font-size: 10pt;
    }

    table.profile {
      border-style: solid;
      border-width: 0px;
      border-color: #000000;
      font-family: serif;
      font-size: 10pt;
      margin-top: 8px;
      margin-left: 8px;
      margin-right: 8px;
      margin-bottom: 8px;
    }

    table.belt {
      border-style: solid;
      border-width: 0px;
      border-color: #000000;
      background-color: #ffeedd;
      padding: 0px 0px;
      width: 100%;
    }

    table.content {
      border-style: solid;
      border-width: 0px;
      border-color: #000000;
      padding: 2px 4px;
    }

    table.font-fixed {
      border-style: solid;
      border-width: 0px;
      border-color: #000000;
      padding: 2px 4px;
      font-family: monospace;
    }

    table.nest {
      border-style: solid;
      border-width: 0px;
      border-color: #000000;
      padding: 0px 0px;
    }

    td {
      padding: 0px 0px;
      vertical-align: middle;
    }

    td.center {
      text-align: center;
    }

    td.center-half {
      text-align: center;
      width: 50%;
      font-size: 8pt;
    }

    td.center-small {
      text-align: center;
      font-size: 8pt;
      padding: 0px 4px;
    }

    td.center-small-nopadding {
      text-align: center;
      font-size: 8pt;
      padding: 0px 0px;
    }

    td.center-white {
      text-align: center;
      background-color: #ffffff;
    }

    td.center-small-white {
      text-align: center;
      font-size: 8pt;
      background-color: #ffffff;
    }

    td.center-border1 {
      text-align: center;
      vertical-align: middle;
      empty-cells: show;
      border-style: solid;
      border-width: 1px;
      border-color: #ffc080;
      width: 22px;
      height: 22px;
    }

    td.left-small {
      text-align: left;
      font-size: 8pt;
      padding: 0px 4px;
    }

    td.left-small-white {
      text-align: left;
      font-size: 8pt;
      padding: 0px 4px;
      background-color: #ffffff;
    }

    td.right-small {
      text-align: right;
      font-size: 8pt;
      padding: 0px 4px;
    }

    td.right-small-white {
      text-align: right;
      font-size: 8pt;
      padding: 0px 4px;
      background-color: #ffffff;
    }

    th {
      padding: 0px 0px;
      vertical-align: middle;
    }

    #menu {
      margin: 0px 0px 0px 0px;
      padding: 0px;
      height: 32px;
    }

    #menu ul {
      margin: 0px;
      padding: 0px;
      list-style: none;
      text-align: center;
      clear: both;
    }

    #menu li {
      margin: 0px 5px 0px 0px;
      padding: 0px;
      float: left;
    }

    #menu a {
      display: block;
      padding: 2px 4px;
      text-decoration: none;
      margin: 0px;
      font-weight: bold;
      background: #FFFFFF;
      color: #333333;
      border: 1px solid #666666;
    }

    #menu a:hover {
      display: block;
      padding: 2px 4px;
      border-bottom: 1px solid #000000;
      text-decoration: none;
      background: #FFCC66;
    }

    #menu .current {
      background-color: #F45F57;
      font-weight: bold;
      color: #FFFFFF;
      border: 1px solid #333333;
    }
    -->
  </style>
  <title>ソフトウェア工学II「樹状整列」プログラム</title>
</head>

<body>
  <div id="menu">
    <ul>
      <li><a href="../index.html">ホーム</a></li>
      <li><a href="../Requirement/index.html">要求仕様書</a></li>
      <li><a href="../DevelopmentPlan/index.html">開発計画書</a></li>
      <li><a href="../BasicDesign/index.html">基本設計書</a></li>
      <li><a href="../DetailDesign/index.html">詳細設計書</a></li>
      <li><a href="../TestSpecification/index.html">テスト仕様書</a></li>
      <li><a href="../TestResult/index.html">テスト結果</a></li>
      <li><a href="../DevelopmentResult/index.html">開発実績</a></li>
      <li><a href="../Program/index.html" class="current">プログラム</a></li>
      <li><a href="../Manual/index.html">マニュアル</a></li>
    </ul>
  </div>
  <hr>
  <h2>ソフトウェア工学II「樹状整列」プログラム</h2>
  <ul>
    <li><a href="#Example">Example(メインクラス)</a>
    <li><a href="#Branch">Branch(ブランチを担うクラス)</a>
    <li><a href="#Constants">Constants(リテラルをまとめたクラス)</a>
    <li><a href="#Forest">Forest(フォレストを担うクラス)</a>
    <li><a href="#ForestController">ForestController(コントローラを担うクラス)</a>
    <li><a href="#ForestModel">ForestModel(モデルを担うクラス)</a>
    <li><a href="#ForestView">ForestView(ビューを担うクラス)</a>
    <li><a href="#Node">Node(ノードを担うクラス)</a>
    <li><a href="#forestmf">forest.mf(マニフェストファイル)</a>
    <li><a href="#Make">Makefile(メイクファイル)</a>
    <li><a href="#build">build.xml(ビルドファイル)</a>
  </ul>
  <div class="belt">
    <h3><a name="Example" href="../TestSpecification/index.html#Example">Example（メインクラス）</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

import condition.Condition;

public class Example {
    // ファイルパスを予め設定
    <a name="Example-filePath1Field">private static String filePath1 = "resources/data/tree.txt";</a>
    <a name="Example-filePath2Field">private static String filePath2 = "resources/data/forest.txt";</a>
    <a name="Example-filePath3Field">private static String filePath3 = "resources/data/semilattice.txt";</a>


    <a name="Example-main">public static void main(String[] args) {</a>
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("File Selector");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            // ボタン1
            JButton button1 = new JButton("Run with preset file 1");
            button1.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    runForestModel(filePath1);
                }
            });

            // ボタン2
            JButton button2 = new JButton("Run with preset file 2");
            button2.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    runForestModel(filePath2);
                }
            });

            JButton button3 = new JButton("Run with preset file 3");
            button3.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    runForestModel(filePath3);
                }
            });

            // レイアウトを設定し、ボタンを追加
            frame.setLayout(new FlowLayout());
            frame.getContentPane().add(button1);
            frame.getContentPane().add(button2);
            frame.getContentPane().add(button3);

            frame.setSize(300, 200);
            frame.setVisible(true);
        });
    }

    <a name="Example-runForestModel">public static void runForestModel(String aFilePass) {</a>
    /*// 引数が無い（樹状整列データファイルの在り処がわからない）をチェックする。
		new Condition(() -> arguments.length < 1).ifTrue(() ->
		{
			System.err.println("There are too few arguments.");
			System.exit(1);
		});*/

		// 第1引数で指定された樹状整列データファイルの存在をチェックする。
		File aFile = new File(aFilePass);
		new Condition(() -> !(aFile.exists())).ifTrue(() ->
		{
			System.err.println("'" + aFile + "' does not exist.");
			System.exit(1);
		});

		// MVCを作成する。
		ForestModel aModel = new ForestModel(aFile);
		ForestView aView = new ForestView(aModel);

		// ウィンドウを生成して開く。
		JFrame aWindow = new JFrame(aFile.getName());
		aWindow.getContentPane().add(aView);
		aWindow.setMinimumSize(new Dimension(400, 300));
		aWindow.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		aWindow.setSize(800, 600);
		aWindow.setLocationRelativeTo(null);
		aWindow.setVisible(true);

		// 樹状整列のアニメーションを行う。
        new Thread(() -> aModel.animate()).start();

		return;
    }
}
    </pre>
  <div class="belt">
    <h3><a name="Branch" href="../TestSpecification/index.html#Branch">Branch(ブランチ)を担うクラス</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;

/**
 * 樹状整列におけるブランチ（枝）を担うクラス
 */
public class Branch extends Object
{
	/**
	 * ブランチ（枝）の始点となるノードを記憶するフィールドです。
	 */
	<a name = "Branch-startField">private Node start;</a>

	/**
	 * ブランチ（枝）の終点となるノードを記憶するフィールドです。
	 */
   <a name = "Branch-endField">private Node end;

	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 * @param from ブランチ（枝）の始点となるノード
	 * @param to ブランチ（枝）の終点となるノード
	 */
	<a name="Branch-Branch">public Branch(Node from, Node to)</a>
	{
		super();

		this.start = from;
		this.end = to;

		return;
	}

	/**
	 * ブランチ（枝）を描画するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 */
	<a name="Branch-draw">public void draw(Graphics aGraphics)</a>
	{
		Graphics2D aGraphics2D = (Graphics2D)aGraphics;
		aGraphics2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		aGraphics2D.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

		// ブランチ（枝）の始点座標を計算する。
		Point location = this.start.getLocation();
		Point extent = this.start.getExtent();
		Integer x1 = location.x + extent.x;
		Integer y1 = location.y + (extent.y / 2);

		// ブランチ（枝）の終点座標を計算する。
		location = this.end.getLocation();
		extent = this.end.getExtent();
		Integer x2 = location.x;
		Integer y2 = location.y + (extent.y / 2);

		// ブランチ（枝）の線を描画コンテクストへ描き出す。
		aGraphics.setColor(Constants.ForegroundColor);
		aGraphics.drawLine(x1, y1, x2, y2);

		return;
	}

	/**
	 * ブランチ（枝）の終点となるノードを応答するメソッドです。
	 * @return 終点ノード
	 */
	<a name="Branch-end">public Node end()</a>
	{
		return this.end;
	}

	/**
	 * ブランチ（枝）の始点となるノードを応答するメソッドです。
	 * @return 始点ノード
	 */
	<a name="Branch-start">public Node start()</a>
	{
		return this.start;
	}

	/**
	 * 自分自身を文字列に変換するメソッドです。
	 * @return 自分自身を表す文字列
	 */
	@Override
	<a name="Branch-toString">public String toString()</a>
	{
		Class<?> aClass = this.getClass();

		StringBuffer aBuffer = new StringBuffer();
		aBuffer.append(aClass.getName());
		aBuffer.append("[");
		aBuffer.append(this.start.getName());
		aBuffer.append(", ");
		aBuffer.append(this.end.getName());
		aBuffer.append("]");

		return aBuffer.toString();
	}
}

    </pre>
  <div class="belt">
    <h3><a name="Constants" href="../TestSpecification/index.html#Constants">Constants(リテラルをまとめたクラス)</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Color;
import java.awt.Font;
import java.awt.Point;

/**
 * 定数たち：すべてパブリック＆スタティック＆ファイナルの宣言で、このクラスのクラス変数（フィールド）としてアクセス
 */
public class Constants extends Object
{
	/**
	 * このクラスのコンストラクタですが、使う必要がありませんので、private宣言する。
	 */
   <a name="Constants-Constants">private Constants() { super(); }</a>

	/**
	 * 樹状整列データファイル中のタグ「ツリー」を表します。
	 */
	<a name="Constants-TagOfTrees">public static final String TagOfTrees = "trees:";</a>

	/**
	 * 樹状整列データファイル中のタグ「ノード」を表します。
	 */
   <a name="Constants-TagOfNodes">public static final String TagOfNodes = "nodes:";</a>

	/**
	 * 樹状整列データファイル中のタグ「ブランチ」を表します。
	 */
   <a name="Constants-TagOfBranches">public static final String TagOfBranches = "branches:";</a>

	/**
	 * ノードを描く際のラベルの文字色を表します。
	 */
   <a name="Constants-ForegroundColor">public static final Color ForegroundColor = Color.black;</a>

	/**
	 * ノードを描く際のラベルの背景色を表します。
	 */
   <a name="Constants-BackgroundColor">public static final Color BackgroundColor = Color.white;</a>

	/**
	 * ノードを描く際のラベルのフォントを表します。
	 */
   <a name="Constants-DefaultFont">//public static final Font DefaultFont = new Font("Serif", Font.PLAIN, 12);
	public static final Font DefaultFont = new Font("Monospaced", Font.PLAIN, 12);</a>
	
	/**
	 * ノードにおいてラベルを描く際の枠縁から余裕（マージン）を表します。
	 */
   <a name="Constants-Mergin">public static final Point Mergin = new Point(2, 1);</a>
	
	/**
	 * ノード群を樹状に整列させる際にノード同士の間隔を表します。
	 */
   <a name="Constants-Interval">public static final Point Interval = new Point(25, 2);</a>
	
	/**
	 * ノード群を深さ優先にたどる際の状態「未定」を表します。
	 */
   <a name="Constants-UnKnown">public static final Integer UnKnown = -1;</a>
	
	/**
	 * ノード群を深さ優先にたどる際の状態「未訪問」を表します。
	 */
   <a name="Constants-UnVisited">public static final Integer UnVisited = 0;</a>
	
	/**
	 * ノード群を深さ優先にたどる際の状態「訪問済」を表します。
	 */
   <a name="Constants-Visited">public static final Integer Visited = 1;</a>
	
	/**
	 * 樹状整列アニメーションのチックタック：時間間隔：スピードを表します。
	 */
   <a name="Constants-SleepTick">public static final Integer SleepTick = 100;</a>
}

    </pre>
  <div class="belt">
    <h3><a name="Forest" href="../TestSpecification/index.html#Forest">Forest(フォレストを担うクラス)</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;

import condition.Condition;
import condition.ValueHolder;

/**
 * 樹状整列におけるフォレスト（木・林・森・亜格子状の森）を担うクラス
 */
public class Forest extends Object
{
	/**
	 * ノード（節）群（たち）を記憶するフィールドです。
	 */
	<a name="Forest-nodesField">private List&lt;Node&gt; nodes;</a>

	/**
	 * ブランチ（枝）群（たち）を記憶するフィールドです。
	 */
   <a name="Forest-branchesField">private List&lt;Branch&gt; branches;</a>

	/**
	 * 樹状整列したフォレスト（森）の領域（矩形）を記憶するフィールドです。
	 */
   <a name="Forest-boundsField">private Rectangle bounds;</a>

	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 */
   <a name="Forest-Forest">public Forest()</a>
	{
		super();

		this.nodes = new ArrayList&lt;Node&gt;();
		this.branches = new ArrayList&lt;Branch&gt;();
		this.bounds = null;

		return;
	}

	/**
	 * ブランチ（枝）を追加するメソッドです。
	 * @param aBranch ブランチ（枝）
	 */
   <a name="Forest-addBranch">public void addBranch(Branch aBranch)</a>
	{
		this.branches.add(aBranch);
		this.flushBounds();

		return;
	}

	/**
	 * ノード（節）を追加するメソッドです。
	 * @param aNode ノード（節）
	 */
   <a name="Forest-addNode">public void addNode(Node aNode)</a>
	{
		this.nodes.add(aNode);
		this.flushBounds();

		return;
	}

	/**
	 * 樹状整列するトップ（一番上位）のメソッドです。
	 */
   <a name="Forest-arrange">public void arrange()</a>
	{
		this.arrange(null);

		return;
	}

	/**
	 * 樹状整列するセカンドレベル（二番階層）のメソッドです。
	 * @param aModel モデル
	 */
   <a name="Forest-arrange2">public void arrange(ForestModel aModel)</a>
	{
		Integer fontHeight = Constants.DefaultFont.getSize();
		Integer yValue = fontHeight + (Constants.Margin.y * 2) + Constants.Interval.y;

		ValueHolder<Integer> anIndex = new ValueHolder<Integer>(0);
		this.nodes.forEach((Node aNode) ->
		{
			aNode.setStatus(Constants.UnVisited);
			aNode.setLocation(new Point(0, anIndex.getAndSetDo((Integer it) -> it + 1) * yValue));
		});

		ValueHolder<Point> aPoint = new ValueHolder<Point>(new Point(0, 0));
		this.rootNodes().forEach((Node aNode) ->
		{
			aPoint.set(this.arrange(aNode, aPoint.get(), aModel));
			aPoint.set(new Point(0, aPoint.get().y + Constants.Interval.y));
		});

		this.flushBounds();

		return;
	}

	/**
	 * 樹状整列する再帰レベル（N番階層）のメソッドです。
	 * @param aNode ノード（このノードから再帰的にたどって下位のものたちも整列する）
	 * @param aPoint ノードの位置（座標）
	 * @param aModel モデル（nullのときはアニメーションを行わない）
	 * @return 樹状整列に必要だった大きさ（幅と高さ）
	 */
   <a name="Forest-arrangeN">protected Point arrange(Node aNode, Point aPoint, ForestModel aModel)</a>
	{
		aNode.setStatus(Constants.Visited);
		aNode.setLocation(aPoint);
		this.propagate(aModel);

		ValueHolder<Point> extent = new ValueHolder<Point>(aNode.getExtent());
		List<Node> subNodes = this.subNodes(aNode);
		try
		{
			new Condition(() -> subNodes.size() <= 0).ifTrue(() ->
			{
				Integer width = aPoint.x + extent.get().x;
				Integer height = aPoint.y + extent.get().y;
				extent.set(new Point(width, height));

				throw new RuntimeException();
			});
		}
		catch (RuntimeException anException) { return(extent.get()); }

		ValueHolder<Integer> width = new ValueHolder<Integer>(aPoint.x + extent.get().x);
		ValueHolder<Integer> height = new ValueHolder<Integer>(aPoint.y);
		ValueHolder<Integer> x = new ValueHolder<Integer>(width.get() + Constants.Interval.x);
		ValueHolder<Integer> y = new ValueHolder<Integer>(height.get());
		ValueHolder<Integer> top = new ValueHolder<Integer>(height.get());

		subNodes.forEach((Node subNode) ->
		{
			new Condition(() -> subNode.getStatus() == Constants.UnVisited).ifTrue(() ->
			{
				extent.set(this.arrange(subNode, new Point(x.get(), y.get()), aModel)); // 再帰
				Integer h = y.get() + subNode.getExtent().y;
				y.set((extent.get().y > h) ? (extent.get().y) : (h));
				width.set((extent.get().x > width.get()) ? (extent.get().x) : (width.get()));
				height.set((extent.get().y > height.get()) ? (extent.get().y) : (height.get()));
				y.set(y.get() + Constants.Interval.y);
			});
		});

		y.set(y.get() - Constants.Interval.y);
		Integer h = aNode.getExtent().y;
		new Condition(() -> y.get() > (aPoint.y + h)).ifTrue(() ->
		{
			y.set(top.get() + ((y.get() - top.get() - h) / 2));
			aNode.setLocation(new Point(aPoint.x, y.get()));
			this.propagate(aModel);
		});
		height.set((height.get() > h) ? (height.get()) : (h));
		extent.set(new Point(width.get(), height.get()));

		return extent.get();
	}

	/**
	 * フォレスト（木・林・森・亜格子状の森）の領域（矩形）を応答するメソッドです。
	 * @return aGraphics フォレスト領域（矩形）
	 */
   <a name="Forest-bounds">public Rectangle bounds()</a>
	{
		// 領域（矩形）が水に流（チャラに）されているときだけ計算する。
		new Condition(() -> this.bounds == null).ifTrue(() ->
		{
			this.bounds = new Rectangle(0, 0, 0, 0);
			ValueHolder<Integer> anIndex = new ValueHolder<Integer>(0);
			this.nodes.forEach((Node aNode) ->
			{
				this.bounds.add(aNode.getBounds());
				anIndex.getAndSetDo((Integer it) -> it + 1);
			});
		});

		return this.bounds;
	}

	/**
	 * フォレスト（木・林・森・亜格子状の森）を描画するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 */
   <a name="Forest-draw">public void draw(Graphics aGraphics)</a>
	{
		// 樹状整列の領域（矩形）を確と求めておく。
		this.bounds();

		// ブランチ（枝）群（たち）を描画する。
		this.branches.forEach((Branch aBranch) -> { aBranch.draw(aGraphics); });

		// ノード（節）群（たち）を描画する。
		this.nodes.forEach((Node aNode) -> { aNode.draw(aGraphics); });

		return;
	}

	/**
	 * フォレスト（木・林・森・亜格子状の森）の領域（矩形）を水に流す（チャラにする）メソッドです。
	 */
   <a name="Forest-flushBounds">public void flushBounds()</a>
	{
		this.bounds = null;

		return;
	}

	/**
	 * チックタックの間、スリープし、モデルが変化した、と騒ぐ（広める：放送する）メソッドです。
	 * @param aModel モデル
	 */
   <a name="Forest-propagate">protected void propagate(ForestModel aModel)</a>
	{
		new Condition(() -> !(aModel == null)).ifTrue(() ->
		{
			try { Thread.sleep(Constants.SleepTick); }
			catch (InterruptedException anException) { ; }
			this.flushBounds();
			aModel.changed();
		});

		return;
	}

	/**
	 * フォレストの根元（ルート）となるノード群を応答するメソッドです。
	 * @return ルートノード群
	 */
   <a name="Forest-rootNodes">public List&lt;Node&gt; rootNodes()</a>
	{
		List&lt;Node&gt; rootNodes = new ArrayList&lt;Node&gt;();
		this.nodes.forEach((Node aNode) ->
		{
			new Condition(() -> this.superNodes(aNode).size() == 0).ifTrue(() -> { rootNodes.add(aNode); });
		});

		return this.sortNodes(rootNodes);
	}

	/**
	 * 引数で指定されたノード群をノード名でソート（並び替えを）するメソッドです。
	 * @param nodeCollection ノード群
	 * @return ソートされたノード群
	 */
   <a name="Forest-sortNodes">protected List&lt;Node&gt; sortNodes(List&lt;Node&gt; nodeCollection)</a>
	{
		ValueHolder&lt;Integer&gt; i = new ValueHolder&lt;Integer&gt;(0);
		new Condition(() -> i.get() < (nodeCollection.size() - 1)).whileTrue(() ->
		{
			ValueHolder&lt;Integer&gt; j = new ValueHolder&lt;Integer&gt;(nodeCollection.size() - 1);
			new Condition(() -> j.get() > i.get()).whileTrue(() ->
			{
				Node current = nodeCollection.get(j.get());
				Node previous = nodeCollection.get(j.get() - 1);
				new Condition(() -> (current.getName()).compareTo(previous.getName()) < 0).ifTrue(() ->
				{
					Node temporary = current;
					nodeCollection.set(j.get(), previous);
					nodeCollection.set(j.get() - 1, temporary);
				});
				j.set(j.get() - 1);
			});
			i.set(i.get() + 1);
		});

		return nodeCollection;
	}

	/**
	 * 引数で指定されたノードのサブノード群を応答するメソッドです。
	 * @param aNode ノード
	 * @return サブノード群
	 */
   <a name="Forest-subNodes">public List&lt;Node&gt; subNodes(Node aNode)</a>
	{
		List&lt;Node&gt; subNodes = new ArrayList&lt;Node&gt;();
		this.branches.forEach((Branch aBranch) ->
		{
			new Condition(() -> aBranch.start() == aNode).ifTrue(() -> { subNodes.add(aBranch.end()); });
		});

		return this.sortNodes(subNodes);
	}

	/**
	 * 引数で指定されたノードのスーパーノード群を応答するメソッドです。
	 * @param aNode ノード
	 * @return スーパーノード群
	 */
   <a name="Forest-superNodes">public List&lt;Node&gt; superNodes(Node aNode)</a>
	{
		List&lt;Node&gt; superNodes = new ArrayList&lt;Node&gt;();
		this.branches.forEach((Branch aBranch) ->
		{
			new Condition(() -> aBranch.end() == aNode).ifTrue(() -> { superNodes.add(aBranch.start()); });
		});

		return this.sortNodes(superNodes);
	}

	/**
	 * 自分自身を文字列に変換するメソッドです。
	 * @return 自分自身を表す文字列
	 */
	@Override
	<a name="Forest-toString">public String toString()</a>
	{
		Class&lt;?&gt; aClass = this.getClass();

		StringBuffer aBuffer = new StringBuffer();
		aBuffer.append(aClass.getName());
		aBuffer.append("[bounds=");
		aBuffer.append(this.bounds);
		aBuffer.append(", nodes=");
		aBuffer.append(this.nodes);
		aBuffer.append(", branches=");
		aBuffer.append(this.branches);
		aBuffer.append("]");

		return aBuffer.toString();
	}

	/**
	 * 指定された位置（座標）にノードが存在するかを調べるメソッドです。
	 * @param aPoint 位置（モデル座標）
	 * @return ノード、もしも見つからなかった場合には、nullを応答します。
	 */
   <a name="Forest-whichOfNodes">public Node whichOfNodes(Point aPoint)</a>
	{
		ValueHolder&lt;Node&gt; returnValue = new ValueHolder&lt;Node&gt;(null);
		try
		{
			this.nodes.forEach((Node aNode) ->
			{
				Rectangle aRetangle = aNode.getBounds();
				new Condition(() -> aRetangle.contains(aPoint)).ifTrue(() ->
				{
					returnValue.set(aNode);
					throw new RuntimeException();
				});
			});
		}
		catch (RuntimeException anException) { ; }

		return returnValue.get();
	}
}

    </pre>
  <div class="belt">
    <h3><a name="ForestController"
        href="../TestSpecification/index.html#ForestController">ForestController(コントローラを担うクラス)</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Point;
import java.awt.event.MouseEvent;

import javax.swing.JOptionPane;

import condition.Condition;
import mvc.Controller;

/**
 * 樹状整列におけるMVCのコントローラ（C）を担うクラス
 */
public class ForestController extends Controller
{
	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 */
   <a name="ForestController-ForestController">public ForestController()</a>
	{
		super();

		return;
	}

	/**
	 * マウスのボタンをクリックしたときに動作するメソッドです。
	 * クリックした位置からノードを割り出します。
	 * @param aMouseEvent マウスイベント
	 */
	@Override
	<a name="ForestController-mouseClicked">public void mouseClicked(MouseEvent aMouseEvent)</a>
	{
		// イベントからクリック座標を取得し、その座標にノードがあるかを調べる。
		Point aPoint = aMouseEvent.getPoint();
		System.out.println(aPoint);
		Node aNode = ((ForestView)this.view).whichOfNodes(aPoint);

		// 当該座標にノードがあった場合（null以外）にノード名（ラベル）を書き出す。
		new Condition(() -> !(aNode == null)).ifTrue(() ->
		{
			String aString = aNode.getName();
			System.out.println(aString);
			JOptionPane.showConfirmDialog(null, aString, "情報",
			                              JOptionPane.DEFAULT_OPTION,
			                              JOptionPane.INFORMATION_MESSAGE);
		});

		return;
	}
}

    </pre>
  <div class="belt">
    <h3><a name="ForestModel" href="../TestSpecification/index.html#ForestModel">ForestModel(モデルを担うクラス)</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import mvc.Model;
import mvc.View;
import condition.Condition;
import condition.ValueHolder;

/**
 * 樹状整列におけるMVCのモデル（M）を担うクラス
 */
public class ForestModel extends Model
{
	/**
	 * 樹状整列それ自身を記憶しておくフィールドです。
	 */
   <a name="ForestModel-forestField">private Forest forest;</a>

	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 * @param aFile 樹状整列データファイル
	 */
   <a name="ForestModel-ForestModel">public ForestModel(File aFile)</a>
	{
		super();

		// フォレストのインスタンスを生成して保持し、樹状整列データファイルを読み込んで、樹状整列させる。
		this.forest = new Forest();
		ValueHolder&lt;BufferedReader&gt; readStream = new ValueHolder&lt;BufferedReader&gt;(null);
		try
		{
			readStream.set(new BufferedReader(new FileReader(aFile)));
			this.read(readStream.get());
		}
		catch (FileNotFoundException anException)
		{
			System.err.println(anException);
			throw new RuntimeException(anException);
		}
		finally
		{
			new Condition(() -&gt; readStream.get() != null).ifTrue(() -&gt;
			{
				try { readStream.get().close(); }
				catch (IOException anException)
				{
					System.err.println(anException);
					throw new RuntimeException(anException);
				}
			});
		}
		this.arrange();

		return;
	}

	/**
	 * アニメーションを行うメソッドです。
	 */
   <a name="ForestModel-animate">public void animate()</a>
	{
		// フォレストの樹状整列に自分を引数で渡すので、propagateによりアニメーションが行われる。
		this.forest.arrange(this);
		this.changed();

		return;
	}

	/**
	 * 樹状整列を行うメソッドです。
	 */
   <a name="ForestModel-arrange">public void arrange()</a>
	{
		// フォレストの樹状整列に引数無しですので、アニメーションは行われない。
		this.forest.arrange();
		this.changed();

		return;
	}

	/**
	 * 自分自身が変化したことを依存物たちに放送（updateを依頼）するメソッドです。
	 */
	@Override
	<a name="ForestModel-changed">public void changed()</a>
	{
		// 樹状整列の境界領域を求め、その領域の幅と高さの画像を生成する。
		Rectangle aRectangle = this.forest.bounds();
		this.picture(new BufferedImage(aRectangle.width, aRectangle.height, BufferedImage.TYPE_INT_RGB));

		// 画像の描画コンテクスト（グラフィックス）を取り出し、それを背景色で塗りつぶす。
		Graphics aGraphics = this.picture().createGraphics();
		aGraphics.setColor(Constants.BackgroundColor);
		aGraphics.fillRect(0, 0, aRectangle.width, aRectangle.height);

		// 樹状整列を画像の描画コンテクスト（グラフィックス）に描き出す。
		this.forest.draw(aGraphics);

		// モデルが変化していることを依存物であるビューたちへ放送（updateを依頼）する。
		this.dependents.forEach((View aView) -&gt; { aView.update(); });

		return;
	}

	/**
	 * 樹状整列それ自身を応答するメソッドです。
	 * @return 樹状整列それ自身
	 */
   <a name="ForestModel-forest">public Forest forest()</a>
	{
		return this.forest;
	}

	/**
	 * 樹状整列データファイルから樹状整列それ自身を生成するメソッドです。
	 * @param readStream 樹状整列データファイルストリーム
	 */
   <a name="ForestModel-read">protected void read(BufferedReader readStream)</a>
	{
		// 樹状整列データファイルを読み込んで、ツリー（木）たち、ノード（節）たち、ブランチ（枝）たち、を割り出す。
		List&lt;String&gt; trees = new ArrayList&lt;String&gt;();
		List&lt;String&gt; nodes = new ArrayList&lt;String&gt;();
		List&lt;String&gt; branches = new ArrayList&lt;String&gt;();
		ValueHolder&lt;String&gt; string = new ValueHolder&lt;String&gt;(null);
		new Condition(() -&gt;
		{
			string.set(this.readLine(readStream));
			return (string.get()) != null;
		}).whileTrue(() -&gt;
		{
			new Condition(() -&gt;
				string.get().equals(Constants.TagOfTrees)
			).ifTrue(() -&gt;
			{
				string.set(this.readLine(readStream));
				new Condition(() -&gt;
					string.get() != null && !(string.get().equals(Constants.TagOfNodes))
				).whileTrue(() -&gt;
				{
					trees.add(string.get());
					string.set(this.readLine(readStream));
				});
			});

			new Condition(() -&gt;
				string.get() != null && string.get().equals(Constants.TagOfNodes)
			).whileTrue(() -&gt;
			{
				string.set(this.readLine(readStream));
				new Condition(() -&gt;
					string.get() != null && !(string.get().equals(Constants.TagOfBranches))
				).whileTrue(() -&gt;
				{
					nodes.add(string.get());
					string.set(this.readLine(readStream));
				});
			});

			new Condition(() -&gt;
				string.get() != null && string.get().equals(Constants.TagOfBranches)
			).whileTrue(() -&gt;
			{
				string.set(this.readLine(readStream));
				new Condition(() -&gt;
					string.get() != null
				).whileTrue(() -&gt;
				{
					branches.add(string.get());
					string.set(this.readLine(readStream));
				});
			});
		});

		// ノードたちを生成して登録する。
		Node[] nodeArray = new Node[nodes.size()];
		nodes.forEach((String aString) -&gt;
		{
			String[] stringArray = aString.split(", ");
			new Condition(() -&gt; stringArray.length == 2).ifTrue(() -&gt;
			{
				Integer anIndex = Integer.parseInt(stringArray[0]) - 1;
				Node aNode = new Node(stringArray[1]);
				nodeArray[anIndex] = aNode;
				this.forest.addNode(aNode);
			});
		});

		// ブランチたちを生成して登録する。
		branches.forEach((String aString) -&gt;
		{
			String[] stringArray = aString.split(", ");
			new Condition(() -&gt; stringArray.length == 2).ifTrue(() -&gt;
			{
				Node fromNode = nodeArray[Integer.parseInt(stringArray[0]) - 1];
				Node toNode = nodeArray[Integer.parseInt(stringArray[1]) - 1];
				Branch aBranch = new Branch(fromNode, toNode);
				this.forest.addBranch(aBranch);
			});
		});

		return;
	}

	/**
	 * 樹状整列データファイルストリームから一行分を読み出して応答するメソッドです。
	 * @param readStream 樹状整列データファイルストリーム
	 * @return 一行分の文字列
	 */
   <a name="ForestModel-readLine">protected String readLine(BufferedReader readStream)</a>
	{
		String aString = null;
		try { aString = readStream.readLine(); }
		catch (IOException anException)
		{
			System.err.println(anException);
			throw new RuntimeException(anException);
		}

		return aString;
	}

	/**
	 * 樹状整列の根元（ルート）になるノードを探し出して応答するメソッドです。
	 * @return ルートノード、ただし、見つからないときはnull
	 */
   <a name="ForestModel-root">public Node root()</a>
	{
		List&lt;Node&gt; roots = this.roots();

		return (roots.size() &gt; 0) ? (roots.get(0)) : (null);
	}

	/**
	 * 樹状整列の根元（ルート）になるノードたちを探し出して応答するメソッドです。
	 * @return ルートノードたち、ただし、見つからないときは空リスト
	 */
   <a name="ForestModel-roots">public List&lt;Node&gt; roots()</a>
	{
		return this.forest().rootNodes();
	}
}

  </pre>
  <div class="belt">
    <h3><a name="ForestView" href="../TestSpecification/index.html#ForestView">ForestView(ビューを担うクラス)</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.image.BufferedImage;

import mvc.View;
import condition.Condition;

/**
 * 樹状整列におけるMVCのビュー（V）を担うクラス
 */
@SuppressWarnings("serial")
public class ForestView extends View
{
	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 * @param aModel モデル（Modelのインスタンス）
	 */
   <a name="ForestView-ForestView">public ForestView(ForestModel aModel)</a>
	{
		super(aModel, new ForestController());

		return;
	}

	/**
	 * このパネル（ビュー）の描画が必要になったときに動作するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 */
	@Override
	<a name="ForestView-paintComponent">public void paintComponent(Graphics aGraphics)</a>
	{
		// 自分（ビュー：パネルのサブクラス）の幅と高さを取得する。
		Integer width = this.getWidth();
		Integer height = this.getHeight();

		// 自分の内部を背景色で塗りつぶす。
		aGraphics.setColor(Constants.BackgroundColor);
		aGraphics.fillRect(0, 0, width, height);

		// モデルが設定されているときにモデルを描画する。
		new Condition(() -&gt; this.model != null).ifTrue(() -&gt;
		{
			// モデルのピクチャ（画像）がある場合には、それをグラフィクス（描画コンテクスト）に描き出す。
			BufferedImage picture = this.model.picture();
			new Condition(() -&gt; picture != null).ifTrue(() -&gt;
			{
				Integer x = 0 - this.scrollAmount().x;
				Integer y = 0 - this.scrollAmount().y;
				aGraphics.drawImage(picture, x, y, null);
			});
		});

		return;
	}

	/**
	 * 指定された位置（座標）にノードが存在するかを調べるメソッドです。
	 * @param aPoint 位置（ビュー座標）
	 * @return ノード、もしも見つからなかった場合には、nullを応答します。
	 */
   <a name="ForestView-whichOfNodes">public Node whichOfNodes(Point aPoint)</a>
	{
		// 引数で指定されたビュー座標からスクロール量を減じてモデル座標に変換する。
		Integer x = aPoint.x + this.scrollAmount().x;
		Integer y = aPoint.y + this.scrollAmount().y;

		// データ管理をしているモデルから樹状整列のインスタンスを取得する。
		Forest aForest = ((ForestModel)this.model).forest();

		// 樹状整列のインスタンスへモデル座標を渡して、そこにノードが存在するかを調べてもらう。
		Node aNodeOrNull = aForest.whichOfNodes(new Point(x, y));

		return aNodeOrNull;
	}
}

    </pre>
  <div class="belt">
    <h3><a name="Node" href="../TestSpecification/index.html#Node">Node(ノードを担うクラス)</a></h3>
  </div>
  <pre>
    package forest;

import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;

import javax.swing.SwingUtilities;

/**
 * 樹状整列におけるノード（節）を担うクラス
 */
@SuppressWarnings("serial")
public class Node extends Component
{
	/**
	 * ノード名：ラベル文字列を記憶するフィールドです。
	 */
   <a name="Node-nameField">private String name;</a>

	/**
	 * ノードの場所（位置：座標）を記憶するフィールドです。
	 */
   <a name="Node-locationField">private Point location;</a>

	/**
	 * ノードの大きさ（幅と高さ）を記憶するフィールドです。
	 */
   <a name="Node-extentField">private Point extent;</a>

	/**
	 * 樹状整列する際のノードの状態を記憶するフィールドです。
	 */
   <a name="Node-statusField">private Integer status;</a>

	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 * @param aString ノード名：ラベル文字列
	 */
   <a name="Node-Node">public Node(String aString)</a>
	{
		super();

		this.setName(aString);
		this.setLocation(new Point(0, 0));

		// ノード名のラベル文字列のフォントフォント情報から幅と高さを計算する。
		Integer width = this.stringWidth(this.name) + (Constants.Margin.x * 2);
		Integer height = this.stringHeight(this.name) + (Constants.Margin.y * 2);
		this.setExtent(new Point(width, height));

		// 樹状整列のノードのステータス（状態）を未定として初期化する。
		this.setStatus(Constants.UnKnown);

		return;
	}

	/**
	 * ノード（節）を描画するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 */
   <a name="Node-draw">public void draw(Graphics aGraphics)</a>
	{
		Graphics2D aGraphics2D = (Graphics2D)aGraphics;
		aGraphics2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		aGraphics2D.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

		// ノード（節）の枠縁を描き出す。
		aGraphics.setColor(Constants.ForegroundColor);
		aGraphics.drawRect(this.location.x, this.location.y, this.extent.x - 1, this.extent.y - 1);

		// ノード（節）の名前（ラベル）を描き出すための座標を計算する。
		String aString = this.getName();
		Point aPoint = (this.getBounds()).getLocation();
		aPoint.translate(Constants.Margin.x, this.extent.y - Constants.Margin.y - 2);

		// ノード（節）の名前（ラベル）を描き出す。
		aGraphics.setFont(Constants.DefaultFont);
		aGraphics.drawString(aString, aPoint.x, aPoint.y) ;

		return;
	}

	/**
	 * ノード（節）の描画領域を応答するメソッドです。
	 * @return ノード（節）の描画領域（Rectangleのインスタンス）
	 */
	@Override
	<a name="Node-getBounds">public Rectangle getBounds()</a>
	{
		Rectangle aRectangle = new Rectangle(this.location.x, this.location.y, this.extent.x, this.extent.y);

		return aRectangle;
	}

	/**
	 * ノード（節）の大きさを応答するメソッドです。
	 * @return ノード（節）の大きさ（幅と高さ）
	 */
   <a name="Node-getExtent">public Point getExtent()</a>
	{
		return this.extent;
	}

	/**
	 * ノード（節）の位置を応答するメソッドです。
	 * @return ノード（節）の位置（座標）
	 */
	@Override
	<a name="Node-getLocation">public Point getLocation()</a>
	{
		return this.location;
	}

	/**
	 * ノード（節）の名前を応答するメソッドです。
	 * @return ノード名（ラベル文字列）
	 */
	@Override
	<a name="Node-getName">public String getName()</a>
	{
		return this.name;
	}

	/**
	 * ノード（節）の状態を応答するメソッドです。
	 * @return ノードの状態
	 */
   <a name="Node-getStatus">public Integer getStatus()
	{
		return this.status;
	}

	/**
	 * ノード（節）の大きさを設定するメソッドです。
	 * @param aPoint ノードの大きさ（幅と高さ）
	 */
   <a name="Node-setExtent">public void setExtent(Point aPoint)</a>
	{
		this.extent = aPoint;

		return;
	}

	/**
	 * ノード（節）の位置を設定するメソッドです。
	 * @param aPoint ノードの位置（座標）
	 */
	@Override
	<a name="Node-setLocation">public void setLocation(Point aPoint)</a>
	{
		this.location = aPoint;

		return;
	}

	/**
	 * ノード（節）の名前を設定するメソッドです。
	 * @param aString ノードの名前（ラベル）
	 */
	@Override
	<a name="Node-setName">public void setName(String aString)</a>
	{
		this.name = aString;

		return;
	}

	/**
	 * ノード（節）の状態を設定するメソッドです。
	 * @param anInteger ノードの状態
	 */
   <a name="Node-setStatus">public void setStatus(Integer anInteger)</a>
	{
		this.status = anInteger;

		return;
	}

	/**
	 * 文字列の高さを応答するメソッドです。
	 * @param string 文字列
	 * @return 文字列の高さ
	 */
   <a name="Node-stringHeight">protected int stringHeight(String string)</a>
	{
		return Constants.DefaultFont.getSize();
	}

	/**
	 * 文字列の幅を応答するメソッドです。
	 * @param string 文字列
	 * @return 文字列の幅
	 */
   <a name="Node-stringWidth">protected int stringWidth(String string)</a>
	{
		FontMetrics fontMetrics = this.getFontMetrics(Constants.DefaultFont);

		return SwingUtilities.computeStringWidth(fontMetrics, string);
	}

	/**
	 * 自分自身を文字列に変換するメソッドです。
	 * @return 自分自身を表す文字列
	 */
	@Override
	<a name="Node-toString">public String toString()</a>
	{
		Class<?> aClass = this.getClass();

		StringBuffer aBuffer = new StringBuffer();
		aBuffer.append(aClass.getName());
		aBuffer.append("[");
		aBuffer.append(this.name);
		aBuffer.append("]");

		return aBuffer.toString();
	}
}
    </pre>
  <div class="belt">
    <h3><a name="forestmf">forest.mf(マニフェストファイル)</a></h3>
  </div>
  <pre>
    Manifest-Version: 1.0
Main-Class: forest.Example
    </pre>
  <div class="belt">
    <h3><a name="Make">Makefile(メイクファイル)</a></h3>
  </div>
  <pre>
    ANT	= sh ./PreparePMD.sh ; env LC_ALL=ja_JP.UTF-8 ant
ARCHIVE	= $(shell basename `pwd`)
PMD_BIN	= "pmd-bin"
PMD_COMMAND	= ./$(PMD_BIN)/bin/run.sh pmd -d ./ -f text -R ./pmd-rules.xml -l java
PMD_COMMAND_QUICKSTART	= ./$(PMD_BIN)/bin/run.sh pmd -d ./ -f text -R ./pmd-rules-quickstart.xml -l java
PMD_COMMAND_TEXTCOLOR	= ./$(PMD_BIN)/bin/run.sh pmd -d ./ -f textcolor -R ./pmd-rules.xml -l java
PMD_COMMAND_HTML	= ./$(PMD_BIN)/bin/run.sh pmd -d ./ -f html -R ./pmd-rules.xml -l java
PMD_REPORT_HTML	= pmd_report.html

all:
	$(ANT) all

clean:
	$(ANT) clean
	@find . -maxdepth 1 -name "$(PMD_REPORT_HTML)" -exec echo rm -f {} ";" -exec rm -f {} ";"

test:
	$(ANT) test

# 以下を追加、アサーションのために。
assert:
	$(ANT) assert

# 以下を追加、PMDのデフォルトのルールをカスタマイズしたルール「pmd-rules.xml」を用いたコマンドライン出力のために。
pmd: all
	@echo $(PMD_COMMAND)
	@eval $(PMD_COMMAND) 2> /dev/null

# 以下を追加、PMDが推奨するデフォルトのルール「pmd-rules-quickstart.xml」を用いたコマンドライン出力のために。
pmd_quickstart: all
	@echo $(PMD_COMMAND_QUICKSTART)
	@eval $(PMD_COMMAND_QUICKSTART) 2> /dev/null

# 以下を追加、PMDが推奨するデフォルトのルール「pmd-rules.xml」を用いたコマンドライン色付き出力のために。
pmd_textcolor: all
	@echo $(PMD_COMMAND_TEXTCOLOR)
	@eval $(PMD_COMMAND_TEXTCOLOR) 2> /dev/null

# 以下を追加、PMDが推奨するデフォルトのルール「pmd-rules.xml」を用いたHTML出力のために。
pmd_html: all
	@echo $(PMD_COMMAND_HTML) '> ./$(PMD_REPORT_HTML)'
	-@eval $(PMD_COMMAND_HTML) > ./$(PMD_REPORT_HTML) 2> /dev/null
	open -a 'Safari' ./$(PMD_REPORT_HTML)

install:
	$(ANT) install

doc:
	$(ANT) doc

wipe: clean
	@find . -name ".DS_Store" -exec echo rm -f {} ";" -exec rm -f {} ";"
	@find . -maxdepth 1 -name "$(PMD_BIN)" -exec echo rm -f {} ";" -exec rm -f {} ";"
	@find . -maxdepth 1 -type d -name "$(PMD_BIN)-[0-9]*.[0-9]*.[0-9]*" -exec echo rm -rf {} ";" -exec rm -rf {} ";"
	@find .. -maxdepth 1 -name "$(ARCHIVE).zip" -exec echo rm -f {} ";" -exec rm -f {} ";"

#zip:
#	$(ANT) zip

zip: wipe
	(cd ../ ; zip -r ./$(ARCHIVE).zip ./$(ARCHIVE)/ --exclude='*/.svn/*')

lint: pmd
	@:

    </pre>
  <div class="belt">
    <h3><a name="build">build.xml(ビルドファイル)</a></h3>
  </div>
  <pre>
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;project name="Forest" default="all" basedir="."&gt;

	&lt;property name="package" value="forest" /&gt;
	&lt;property name="mvc" value="mvc" /&gt;
	&lt;property name="packagenames" value="${package},${mvc}" /&gt;
	&lt;property name="destdir" value="./Classes" /&gt;
	&lt;property name="docdir" value="./JavaDoc" /&gt;
	&lt;property name="instdir" value="./${ant.project.name}.app/Contents/Resources/Java" /&gt;
	&lt;property name="copyright" value="Copyright 2008-2020 AOKI Atsushi. All Rights Reserved." /&gt;
	&lt;property name="zipname" value="${ant.project.name}" /&gt;

	&lt;target name="all" depends="jar" description="build all"&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="prepare" depends="" description="prepare to compile"&gt;
		&lt;mkdir dir="${destdir}" /&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="compile" depends="prepare" description="compile all sources"&gt;
		&lt;javac
			fork="true"
			srcdir="${basedir}"
			destdir="${destdir}"
			includeAntRuntime="true"
			encoding="UTF-8"
			deprecation="on"
			verbose="false"&gt;
			&lt;compilerarg value="-J-Dfile.encoding=UTF8" /&gt;
			&lt;compilerarg value="-Xlint:all" /&gt;
			&lt;classpath&gt;
				&lt;pathelement location="." /&gt;
				&lt;pathelement location="${mvc}.jar" /&gt;
			&lt;/classpath&gt;
		&lt;/javac&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="jar" depends="compile" description="make jar file"&gt;
		&lt;jar
			jarfile="${package}.jar"
			basedir="${destdir}"
			manifest="${package}.mf"&gt;
			&lt;zipfileset src="${mvc}.jar" /&gt;
		&lt;/jar&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="clean" description="cleaning"&gt;
		&lt;delete dir="${destdir}" /&gt;
		&lt;delete file="${package}.jar" /&gt;
		&lt;delete dir="${docdir}" /&gt;
		&lt;delete dir="${instdir}" /&gt;
		&lt;delete file="../${zipname}.zip" /&gt;
		&lt;delete&gt;
			&lt;fileset dir="${package}" includes="*.class" /&gt;
		&lt;/delete&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="test" depends="all,tree" description="test"&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="tree" depends="all" description="tree"&gt;
		&lt;exec executable="java" spawn="false"&gt;
			&lt;arg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resources/data/tree.txt" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="forest" depends="all" description="forest"&gt;
		&lt;exec executable="java" spawn="false"&gt;
			&lt;arg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resources/data/forest.txt" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="semilattice" depends="all" description="semilattice"&gt;
		&lt;exec executable="java" spawn="false"&gt;
			&lt;arg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resources/data/semilattice.txt" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="install" depends="all" description="install into application"&gt;
		&lt;copy file="${package}.jar" todir="${instdir}" /&gt;
		&lt;copy file="resources/data/forest.txt" todir="${instdir}" /&gt;
		&lt;exec executable="chmod"&gt;
			&lt;arg line="755 ${instdir}/../../MacOS/applet" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="doc" depends="all" description="make document (javadoc)"&gt;
		&lt;mkdir dir="${docdir}" /&gt;
		&lt;javadoc
			locale="ja_JP"
			sourcepath="${basedir}"
			destdir="${docdir}"
			packagenames="${packagenames}"
			author="true"
			version="true"
			charset="UTF-8"
			encoding="UTF-8"
			docencoding="UTF-8"
			linksource="yes"
			additionalparam="-J-Dfile.encoding=UTF-8 -Xdoclint:all"
			access="private"&gt;
			&lt;doctitle&gt;${doc-title}&lt;/doctitle&gt;
			&lt;bottom&gt;${copyright}&lt;/bottom&gt;
			&lt;classpath&gt;
				&lt;pathelement location="." /&gt;
				&lt;pathelement location="${mvc}.jar" /&gt;
			&lt;/classpath&gt;
		&lt;/javadoc&gt;
		&lt;exec executable="open"&gt;
			&lt;arg line="-a 'Safari' ${docdir}/index.html" /&gt;
		&lt;/exec&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

	&lt;target name="zip" depends="clean" description="make zip file"&gt;
		&lt;delete file="../${zipname}.zip" /&gt;
		&lt;zip destfile="../${zipname}.zip"&gt;
			&lt;zipfileset dir="." prefix="${zipname}" /&gt;
		&lt;/zip&gt;
		&lt;exec executable="date" spawn="false" /&gt;
	&lt;/target&gt;

&lt;/project&gt;

    </pre>
  <hr>
  <div class="right-small">Copyright 2023 Project Forest, Updated: 2023/7/28 (Created: 2023/5/30)</div>
</body>

</html>